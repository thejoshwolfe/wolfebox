#!/usr/bin/env python

import sys, os
import time, struct
import socket
import hashlib
python_version = sys.version_info[0]
if python_version == 2:
    bytes_to_str = lambda s: s
    str_to_bytes = lambda s: s
elif python_version == 3:
    bytes_to_str = lambda s: str(s, "utf8")
    str_to_bytes = lambda s: bytes(s, "utf8")

__version__ = "0.0"

# settings
default_settings_str = """{
    # such as "wolfebox.example.com"
    "SERVER_NAME": "",
    "SERVER_PORT": 61086,

    # seconds between checks
    "CHECK_INTERVAL": 60,

    # list of directories to synchronize
    "DIRS": [
        ### "~" is expanded to the user directory (with os.path.expanduser)
        ### synchronizes ~/example/ with the remote name of "example"
        # "~/example",
        ### synchronizes ~/example/ with the remote name of "different-name"
        # ("~/example", "different-name"),
    ],
}
"""
settings_dir = os.path.join(os.path.expanduser("~"), ".config", "wolfebox")
if not os.path.isdir(settings_dir):
    # let any exceptions bubble
    os.makedirs(settings_dir)
settings_path = os.path.join(settings_dir, "config.py")
# try to read settings
try:
    # eval chokes on CRLF sometimes, so use 'U'
    with open(settings_path, "rU") as settings_file:
        settings = eval(settings_file.read())
    if type(settings) != dict:
        raise TypeError()
except:
    # swallow all exceptions from mysterious user code and use default settings
    # TODO: this is bad
    with open(settings_path, "w") as settings_file:
        settings_file.write(default_settings_str)
    settings = eval(default_settings_str)
if settings["SERVER_NAME"] == "":
    sys.exit("ERROR: wolfebox server not configured.\nedit " + settings_path)
dirs = []
for maybe_tuple in settings["DIRS"]:
    if type(maybe_tuple) == tuple:
        path, name = maybe_tuple
    else:
        path = maybe_tuple
        name = os.path.split(maybe_tuple)[1]
    path = os.path.expanduser(path)
    dirs.append((path, name))
if len(dirs) == 0:
    sys.stderr.write("WARNING: no dirs have been configured for synchronization\n")

class IndexEntry:
    def __init__(self, path, md5sum, modified_time):
        """
        path : str - relative to the monitored directory
        md5sum : str - can be "-" for deleted entries
        modified_time : time.struct_time - such as from time.mktime() or time.gmtime()
        """
        self.path = path
        self.md5sum = md5sum
        self.modified_time = modified_time
    def serialize(self):
        return " ".join([
            self.md5sum,
            ":".join(self.modified_time),
            self.path,
        ])

def main():
    try:
        while True:
            for (path, name) in dirs:
                check_dir(path, name)
            time.sleep(settings["CHECK_INTERVAL"])
    except KeyboardInterrupt:
        print("")

def parse_index(index_contents):
    def parse_index_entry(line):
        (md5sum, modified_time_str, path) = line.split(" ", 2)
        modified_time = time.mktime(tuple(int(x) for x in modified_time_str.split(":")))
        return IndexEntry(path, md5sum, modified_time)
    entry_list = [parse_index_entry(line) for line in index_contents.split("\n") if line != ""]
    return {entry.path: entry for entry in entry_list}

def get_local_index(name):
    index_path = os.path.join(settings_dir, name + ".index")
    try:
        with open(index_path) as index_file:
            index_contents = index_file.read()
    except IOError:
        index_contents = ""
    return parse_index(index_contents)

def list_recursive(root_path):
    """always uses forward slashes"""
    root_path = os.path.abspath(root_path)
    for (dirpath, dirnames, filenames) in os.walk(root_path):
        folder = dirpath[len(root_path + "/"):].replace("\\", "/")
        if folder != "":
            folder += "/"
        for filename in filenames:
            yield folder + filename

def get_modified_time(root_path, relative_path):
    """throws OSError sometimes"""
    return os.path.getmtime(root_path + "/" + relative_path)
def get_md5sum(root_path, relative_path):
    with open(root_path + "/" + relative_path, "rb") as file_handle:
        return hashlib.md5(file_handle.read()).hexdigest()
def entry_for_path(root_path, relative_path):
    try:
        modified_time = get_modified_time(root_path, relative_path)
        md5sum = get_md5sum(root_path, relative_path)
    except (IOError, OSError):
        # file is deleted
        modified_time = time.gmtime()
        md5sum = "-"
    return IndexEntry(relative_path, md5sum, modified_time)



def update_local_index(local_index, root_path):
    existing_paths = set(list_recursive(root_path))
    for existing_path in list(existing_paths):
        try:
            try:
                entry = local_index[existing_path]
            except KeyError:
                # new file
                local_index[existing_path] = entry_for_path(root_path, existing_path)
                continue
            # updated or normal
            modified_time = get_modified_time(root_path, existing_path)
            if modified_time == entry.modified_time:
                continue # assume unchanged
            # timestamp is different. make sure md5sum is up to date.
            entry.md5sum = get_md5sum(root_path, existing_path)
        except (IOError, OSError):
            # race conditions! deleted while we were md5sum'ing a previous neighbor
            local_index[existing_path] = entry_for_path(root_path, existing_path)
            existing_paths.remove(entry.path)
            continue

def check_dir(root_path, name):
    local_index = get_local_index(name)
    update_local_index(local_index, root_path)

    return
    remote_index = get_remote_index(name)
    # TODO


def open_connection():
    server_tuple = (settings["SERVER_NAME"], settings["SERVER_PORT"])
    actual_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        actual_connection.connect(server_tuple)
    except socket.gaierror:
        sys.exit("ERROR: Can't connect to the wolfebox server at " + server_tuple)
    return Connection(actual_connection)
class Connection:
    def __init__(self, actual_connection):
        self.connection = actual_connection
    def __del__(self):
        self.connection.close()
    def read(self, length):
        chunks = []
        while length != 0:
            chunk = self.connection.recv(length)
            if len(chunk) == 0:
                break
            chunks.append(chunk)
            length -= len(chunk)
        return str_to_bytes("").join(chunks)
    def read_fmt(self, fmt):
        data = self.read(struct.calcsize(fmt))
        return struct.unpack(fmt, data)[0]
    def read_int(self):
        return self.read_fmt("I")
    def read_long(self):
        return self.read_fmt("Q")
    def read_string(self):
        length = self.read_int()
        return bytes_to_str(self.read(length))

    def write(self, data):
        self.connection.sendall(data)
    def write_fmt(self, fmt, value):
        data = struct.pack(fmt, value)
        self.write(data)
    def write_int(self, value):
        self.write_fmt("I", value)
    def write_long(self, value):
        self.write_fmt("Q", value)
    def write_string(self, value):
        value = str_to_bytes(value)
        self.write_int(len(value))
        self.write(value)


verbose = False
if __name__ == "__main__":
    import optparse
    parser = optparse.OptionParser(version=__version__)
    parser.add_option("-v", "--verbose", action="store_true", default=False)
    (options, args) = parser.parse_args()
    verbose = options.verbose
    main()


